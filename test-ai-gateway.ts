#!/usr/bin/env tsx

/**
 * Script de teste do AI Gateway
 * Execute com: npx tsx test-ai-gateway.ts
 */

import { getGatewayProvider, isGatewayAvailable } from './src/server/ai/gateway/provider';
import { getModelSelector } from './src/server/ai/gateway/model-selector';
import { getCreditMonitor } from './src/server/ai/gateway/credit-monitor';
import { AIProvider } from './src/server/aiProvider';

// Configurar vari√°veis de ambiente para teste
process.env.AI_GATEWAY_API_KEY = process.env.AI_GATEWAY_API_KEY || 'test-key';
process.env.USE_AI_GATEWAY = 'true';

async function testGatewayProvider() {
  console.log('\nüß™ Testando GatewayProvider...\n');

  try {
    // Verificar disponibilidade
    const available = await isGatewayAvailable();
    console.log(`‚úÖ Gateway dispon√≠vel: ${available}`);

    if (!available) {
      console.log('‚ö†Ô∏è  Gateway n√£o est√° dispon√≠vel. Verifique a configura√ß√£o.');
      return false;
    }

    const provider = getGatewayProvider();

    // Testar descoberta de modelos
    console.log('\nüìã Descobrindo modelos...');
    const models = await provider.getAvailableModels();
    console.log(`‚úÖ Modelos encontrados: ${models.length}`);

    // Listar alguns modelos
    if (models.length > 0) {
      console.log('\nüìä Primeiros 5 modelos:');
      models.slice(0, 5).forEach(model => {
        console.log(`  - ${model.id}: ${model.contextWindow} tokens, $${model.pricing?.input || 0}/M input`);
      });
    }

    // Testar providers dispon√≠veis
    const providers = await provider.getProviders();
    console.log(`\n‚úÖ Providers dispon√≠veis: ${providers.join(', ')}`);

    // Testar modelo recomendado
    const recommended = await provider.getRecommendedModels('chat', 3);
    console.log(`\n‚úÖ Modelos recomendados para chat:`);
    recommended.forEach(model => {
      console.log(`  - ${model.id}`);
    });

    // Testar cache
    const cacheStats = provider.getCacheStats();
    console.log('\nüìà Estat√≠sticas do cache:');
    console.log(`  - Modelos em cache: ${cacheStats.modelsCount}`);
    console.log(`  - √öltima atualiza√ß√£o: ${cacheStats.lastModelRefresh}`);

    return true;
  } catch (error) {
    console.error('‚ùå Erro no GatewayProvider:', error);
    return false;
  }
}

async function testModelSelector() {
  console.log('\nüß™ Testando ModelSelector...\n');

  try {
    const selector = getModelSelector();

    // Testar sele√ß√£o para diferentes contextos
    const contexts = ['chat', 'code', 'analysis', 'creative', 'fast', 'economical'];

    for (const context of contexts) {
      console.log(`\nüéØ Selecionando modelo para contexto: ${context}`);
      const model = await selector.selectModel({
        context,
        maxCost: 30,
        speedPriority: context === 'fast' ? 'fast' : 'balanced'
      });

      if (model) {
        console.log(`  ‚úÖ Selecionado: ${model.id}`);
        console.log(`     Context: ${model.contextWindow} tokens`);
        if (model.pricing) {
          console.log(`     Custo: $${model.pricing.input}/M input, $${model.pricing.output}/M output`);
        }
      } else {
        console.log('  ‚ö†Ô∏è  Nenhum modelo adequado encontrado');
      }
    }

    // Testar recomenda√ß√µes
    console.log('\nüìã Testando recomenda√ß√µes...');
    const recommendations = await selector.getRecommendations('chat', {
      budget: 'low',
      priority: 'speed'
    });

    console.log('‚úÖ Top 3 recomenda√ß√µes (budget baixo, prioridade velocidade):');
    recommendations.slice(0, 3).forEach((rec, idx) => {
      console.log(`  ${idx + 1}. ${rec.model.id} - Score: ${rec.score.toFixed(2)}`);
      console.log(`     Raz√µes: ${rec.reasons.join(', ')}`);
    });

    // Testar modelos otimizados
    console.log('\nüí∞ Modelos mais econ√¥micos:');
    const costOptimized = await selector.getCostOptimizedModels(3);
    costOptimized.forEach(model => {
      if (model.pricing) {
        const avgCost = (model.pricing.input + model.pricing.output) / 2;
        console.log(`  - ${model.id}: $${avgCost.toFixed(2)}/M tokens (m√©dia)`);
      }
    });

    return true;
  } catch (error) {
    console.error('‚ùå Erro no ModelSelector:', error);
    return false;
  }
}

async function testCreditMonitor() {
  console.log('\nüß™ Testando CreditMonitor...\n');

  try {
    const monitor = getCreditMonitor();

    // Testar status de cr√©ditos
    console.log('üí≥ Obtendo status de cr√©ditos...');
    const status = await monitor.getCreditStatus();

    console.log(`\n‚úÖ Status atual:`);
    console.log(`  - Saldo: $${status.current.balance.toFixed(2)}`);
    console.log(`  - Total usado: $${status.current.total_used.toFixed(2)}`);
    console.log(`  - √öltima atualiza√ß√£o: ${status.current.last_updated}`);

    // Mostrar alertas
    if (status.alerts.length > 0) {
      console.log('\n‚ö†Ô∏è  Alertas:');
      status.alerts.forEach(alert => {
        console.log(`  - [${alert.type}] ${alert.message}`);
      });
    } else {
      console.log('\n‚úÖ Nenhum alerta ativo');
    }

    // Mostrar proje√ß√µes
    console.log('\nüìä Proje√ß√µes de uso:');
    console.log(`  - Taxa di√°ria: $${status.projection.dailyRate.toFixed(2)}/dia`);
    console.log(`  - Taxa semanal: $${status.projection.weeklyRate.toFixed(2)}/semana`);
    console.log(`  - Taxa mensal: $${status.projection.monthlyRate.toFixed(2)}/m√™s`);

    if (status.projection.daysUntilEmpty !== Infinity) {
      console.log(`  - Dias at√© esgotar: ${status.projection.daysUntilEmpty}`);
      if (status.projection.recommendedTopUp) {
        console.log(`  - Recarga recomendada: $${status.projection.recommendedTopUp}`);
      }
    }

    // Mostrar recomenda√ß√µes
    if (status.recommendations.length > 0) {
      console.log('\nüí° Recomenda√ß√µes:');
      status.recommendations.forEach(rec => {
        console.log(`  ${rec}`);
      });
    }

    // Simular uso
    console.log('\nüîÑ Simulando uso de $0.50...');
    monitor.trackUsage(0.50);

    return true;
  } catch (error) {
    console.error('‚ùå Erro no CreditMonitor:', error);
    return false;
  }
}

async function testAIProviderIntegration() {
  console.log('\nüß™ Testando integra√ß√£o com AIProvider...\n');

  try {
    const provider = AIProvider.getInstance();

    // Testar obten√ß√£o de modelo via Gateway
    console.log('üîÑ Obtendo modelo via AIProvider (com Gateway)...');
    const model = await provider.getModel({
      useGateway: true,
      provider: 'gateway'
    });

    console.log('‚úÖ Modelo obtido com sucesso');
    console.log(`  Tipo: ${typeof model}`);

    // Testar modelo para contexto espec√≠fico
    console.log('\nüéØ Obtendo modelo para contexto "analysis"...');
    const contextModel = await provider.getModelForContext('analysis');
    console.log('‚úÖ Modelo e configura√ß√µes obtidos:');
    console.log(`  - Temperature: ${contextModel.settings.temperature}`);
    console.log(`  - Max Tokens: ${contextModel.settings.maxTokens}`);

    // Verificar modelos dispon√≠veis via Gateway
    console.log('\nüìã Verificando modelos Gateway via AIProvider...');
    const gatewayModels = await provider.getAvailableGatewayModels();
    console.log(`‚úÖ Modelos Gateway dispon√≠veis: ${gatewayModels.length}`);

    // Verificar cr√©ditos via AIProvider
    console.log('\nüí≥ Verificando cr√©ditos via AIProvider...');
    const credits = await provider.getGatewayCredits();
    if (credits) {
      console.log(`‚úÖ Cr√©ditos: $${credits.balance || 0}`);
    } else {
      console.log('‚ö†Ô∏è  N√£o foi poss√≠vel obter cr√©ditos');
    }

    return true;
  } catch (error) {
    console.error('‚ùå Erro na integra√ß√£o com AIProvider:', error);
    return false;
  }
}

async function testAPIs() {
  console.log('\nüß™ Testando APIs REST...\n');

  const baseUrl = 'http://localhost:3457';

  try {
    // Testar API de modelos
    console.log('üì° Testando GET /api/models...');
    const modelsRes = await fetch(`${baseUrl}/api/models`);
    if (modelsRes.ok) {
      const data = await modelsRes.json();
      console.log(`‚úÖ API de modelos: ${data.total} modelos, ${data.providers?.length || 0} providers`);
    } else {
      console.log(`‚ö†Ô∏è  API de modelos retornou: ${modelsRes.status}`);
    }

    // Testar API de cr√©ditos
    console.log('\nüì° Testando GET /api/credits...');
    const creditsRes = await fetch(`${baseUrl}/api/credits`);
    if (creditsRes.ok) {
      const data = await creditsRes.json();
      console.log(`‚úÖ API de cr√©ditos: Saldo $${data.credits?.balance || 0}`);
    } else {
      console.log(`‚ö†Ô∏è  API de cr√©ditos retornou: ${creditsRes.status}`);
    }

    // Testar API de modelos recomendados
    console.log('\nüì° Testando modelos recomendados...');
    const recRes = await fetch(`${baseUrl}/api/models?recommended=true&context=chat`);
    if (recRes.ok) {
      const data = await recRes.json();
      console.log(`‚úÖ Recomenda√ß√µes obtidas para contexto: ${data.context}`);
    } else {
      console.log(`‚ö†Ô∏è  API de recomenda√ß√µes retornou: ${recRes.status}`);
    }

    return true;
  } catch (error) {
    console.error('‚ùå Erro ao testar APIs:', error);
    console.log('üí° Certifique-se de que o servidor est√° rodando em http://localhost:3457');
    return false;
  }
}

async function main() {
  console.log('üöÄ Iniciando testes do AI Gateway Integration\n');
  console.log('=' .repeat(60));

  const results = {
    gateway: false,
    selector: false,
    monitor: false,
    integration: false,
    apis: false
  };

  // Executar testes
  results.gateway = await testGatewayProvider();
  results.selector = await testModelSelector();
  results.monitor = await testCreditMonitor();
  results.integration = await testAIProviderIntegration();

  // Testar APIs apenas se o servidor estiver rodando
  console.log('\n' + '=' .repeat(60));
  console.log('üì° Para testar as APIs, certifique-se de que o servidor est√° rodando.');
  console.log('   Execute: npm run dev');
  console.log('=' .repeat(60));

  // Uncomment to test APIs
  // results.apis = await testAPIs();

  // Resumo final
  console.log('\n' + '=' .repeat(60));
  console.log('üìä RESUMO DOS TESTES');
  console.log('=' .repeat(60));

  Object.entries(results).forEach(([test, passed]) => {
    const icon = passed ? '‚úÖ' : '‚ùå';
    const status = passed ? 'PASSOU' : 'FALHOU';
    console.log(`${icon} ${test.padEnd(15)} ${status}`);
  });

  const totalPassed = Object.values(results).filter(r => r).length;
  const totalTests = Object.values(results).length;

  console.log('\n' + '=' .repeat(60));
  console.log(`üéØ Resultado: ${totalPassed}/${totalTests} testes passaram`);
  console.log('=' .repeat(60));

  // Sair com c√≥digo apropriado
  process.exit(totalPassed === totalTests ? 0 : 1);
}

// Executar testes
main().catch(error => {
  console.error('üí• Erro fatal:', error);
  process.exit(1);
});